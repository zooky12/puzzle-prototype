<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Box-Enter Puzzle Prototype — Server Levels & Cleaner Icons</title>
<style>
body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding:12px; }
#game { border:1px solid #222; image-rendering: crisp-edges; display:block; margin-bottom:12px;}
.toolbar { margin-bottom:6px; }
.toolbar button, .toolbar select { margin-right:6px; margin-bottom:6px; }
.status { font-weight:600; margin-bottom:12px; }
small.hint { color:#666; display:block; margin-top:6px; }
.hidden { display:none !important; }
</style>
</head>
<body>
<h3>Box-Enter Puzzle Prototype — Server Levels & Cleaner Icons</h3>
<canvas id="game" width="480" height="480"></canvas>

<div class="toolbar">
    <div>
        <button id="build-mode-btn">Toggle Build Mode</button>
        <!-- Levels chooser (paste into the toolbar so you can pick levels from /levels/) -->
<div style="margin-top:6px;">
  <label for="server-levels" style="font-size:12px;margin-right:6px;">Levels:</label>
  <select id="server-levels" style="min-width:220px;"></select>
  <button id="refresh-server">Refresh</button>
  <button id="load-server">Load</button>
</div>

    </div>
  <div class="build-controls">
    <div>
    <!-- kept buttons for familiarity - includes new block types -->
    <button data-tile="wall">Wall</button>
    <button data-tile="floor">Floor</button>
    <button data-tile="hole">Hole</button>
    <button data-tile="exit">Exit</button>
    <button data-tile="spikes">Spikes</button>
    <button data-tile="grile">Grile</button>
    <button data-tile="pressurePlate">Pressure Plate</button>
    <button data-tile="box">Box</button>
    <button data-tile="player">Player</button>
    </div>
    <div>
    <button id="export-btn">Export JSON</button>
    <button id="import-btn">Import JSON</button>
    <button id="clear-btn">Clear</button>
    <button id="fill-floor">Fill Floor</button>
    </div>
  </div>

  <div class="play-controls" style="margin-top:6px;">
    <button id="reset-btn">Reset (R)</button>
    <button id="undo-btn">Undo (E)</button>
    <input type="file" id="import-file" style="display:none"/>
  </div>

  <small class="hint">
    Build Mode ON: paint/place/remove. Build Mode OFF: play (WASD). Drag to paint tiles (wall/floor/hole/exit/spikes/grile/pressurePlate). Export/Import levels via JSON.
  </small>
</div>

<div class="status" id="status">Build Mode: OFF</div>

<script>
/* ---------- CONFIG ---------- */
const rows = 12;
const cols = 12;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const tileSize = Math.floor(canvas.width / cols);

/* visual colors */
const colors = {
  empty: '#ffffff',
  wall: '#555555',     // dark grey
  floor: '#dfe6e9',
  hole: '#000000',     // black
  exitActive: '#3cb371',
  exitInactive: '#bfecc4', // pale green
  box: '#f39c12',
  player: '#4c3ce7'
};

/* ---------- BLOCK TYPES (attributes) ---------- */
const BlockTypes = {
  floor: {},
  wall: { isWallForPlayer:true, isWallForBox:true, isNotFly:true },
  hole: { isHoleForPlayer:true, isHoleForBox:true },
  exit: { isEnd:true },
  spikes: { isWallForBox:true, isStickOnFly:true },
  grile: { isHoleForPlayer:true, isHoleForBox:false },
  pressurePlate: { requiresBox:true }
};

const blockBgColor = {
  floor: colors.floor,
  wall: colors.wall,
  hole: colors.hole,
  exit: colors.exitActive,
  spikes: colors.floor,
  grile: colors.hole,
  pressurePlate: colors.floor
};

/* ---------- STATE ---------- */
let base = Array.from({length: rows}, ()=> Array.from({length: cols}, ()=> 'floor'));
let boxes = [];
let player = null;
let buildMode = false;
let selectedTool = 'wall';
let savedSnapshot = null;
let undoStack = [];
let mouseDown = false;

/* ---------- HELPERS ---------- */
function cloneState(){ return { base: base.map(r=>r.slice()), boxes: boxes.map(b=>({x:b.x,y:b.y})), player: player? JSON.parse(JSON.stringify(player)):null }; }
function restoreState(snap){ base = snap.base.map(r=>r.slice()); boxes = snap.boxes.map(b=>({x:b.x,y:b.y})); player = snap.player? JSON.parse(JSON.stringify(snap.player)) : null; updateToolbarVisibility(); draw(); }
function inBounds(x,y){ return x>=0 && x<cols && y>=0 && y<rows; }
function boxAt(x,y){ return boxes.find(b=>b.x===x && b.y===y); }
function removeBoxAt(x,y){ boxes = boxes.filter(b=>!(b.x===x && b.y===y)); }
function addBox(x,y){ if(!boxAt(x,y)) boxes.push({x,y}); }
function moveBox(fromX,fromY,toX,toY){ for(let b of boxes){ if(b.x===fromX && b.y===fromY){ b.x=toX; b.y=toY; return true; } } return false; }
function attr(type, key){ if(!type) return false; const def = BlockTypes[type]; if(!def) return false; return !!def[key]; }

/* ---------- UI: toolbar visibility & selection ---------- */
function updateToolbarVisibility(){
  const buildControls = document.querySelector('.build-controls');
  const playControls = document.querySelector('.play-controls');
  if(buildMode){
    buildControls.classList.remove('hidden');
    playControls.classList.add('hidden');
  } else {
    buildControls.classList.add('hidden');
    playControls.classList.remove('hidden');
  }
  document.getElementById('status').textContent = `Build Mode: ${buildMode ? 'ON' : 'OFF'}`;
}

document.querySelectorAll('.build-controls button[data-tile]').forEach(b=>{
  b.addEventListener('click', ()=> {
    selectedTool = b.dataset.tile;
    document.querySelectorAll('.build-controls button[data-tile]').forEach(btn=> btn.style.outline='');
    b.style.outline = '2px solid #888';
  });
});
document.querySelector('.build-controls button[data-tile="wall"]').style.outline='2px solid #888';

document.getElementById('build-mode-btn').addEventListener('click', ()=>{
  buildMode = !buildMode;
  if(!buildMode){
    savedSnapshot = cloneState();
    undoStack = [ cloneState() ]; // initialize undo with starting state
  }
  updateToolbarVisibility();
  draw();
});

/* ---------- BUILD: click/drag behavior ---------- */
function handleBuildClick(e){
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left)/tileSize);
  const y = Math.floor((e.clientY - rect.top)/tileSize);
  if(!inBounds(x,y)) return;

  if(selectedTool === 'player'){
    if(player && player.x === x && player.y === y) player = null;
    else { player = { mode: 'free', x, y }; if(!base[y][x]) base[y][x] = 'floor'; }
    draw(); return;
  }
  if(selectedTool === 'box'){
    const existing = boxAt(x,y);
    if(existing) removeBoxAt(x,y);
    else { addBox(x,y); if(!base[y][x]) base[y][x] = 'floor'; }
    draw(); return;
  }

  // paint blocks (tile types)
  base[y][x] = selectedTool;
  draw();
}
function handleBuildDrag(e){
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left)/tileSize);
  const y = Math.floor((e.clientY - rect.top)/tileSize);
  if(!inBounds(x,y)) return;
  if(['wall','floor','hole','exit','spikes','grile','pressurePlate'].includes(selectedTool)){
    base[y][x] = selectedTool;
    draw();
  }
}

canvas.addEventListener('mousedown', (e)=>{ if(!buildMode) return; mouseDown = true; handleBuildClick(e); });
canvas.addEventListener('mousemove', (e)=>{ if(!mouseDown || !buildMode) return; handleBuildDrag(e); });
canvas.addEventListener('mouseup', ()=>{ mouseDown=false; });
canvas.addEventListener('mouseleave', ()=>{ mouseDown=false; });

/* ---------- SHORTCUTS ---------- */
window.addEventListener('keydown', (e)=>{
  const key = e.key.toLowerCase();
  if(buildMode){
    if(key === 'e'){ doUndo(); e.preventDefault(); }
    if(key === 'r'){ resetToSaved(); e.preventDefault(); }
    return;
  }
  let dx=0,dy=0;
  if(key==='w') dy=-1;
  else if(key==='s') dy=1;
  else if(key==='a') dx=-1;
  else if(key==='d') dx=1;
  else if(key==='e'){ doUndo(); e.preventDefault(); return; }
  else if(key==='r'){ resetToSaved(); e.preventDefault(); return; }
  else return;
  e.preventDefault();
  attemptMove(dx,dy);
});

/* ---------- UI buttons ---------- */
document.getElementById('fill-floor').addEventListener('click', ()=>{ for(let y=0;y<rows;y++) for(let x=0;x<cols;x++) base[y][x]='floor'; draw(); });
document.getElementById('clear-btn').addEventListener('click', ()=>{ base = Array.from({length: rows}, ()=> Array.from({length: cols}, ()=> 'floor')); boxes = []; player = null; savedSnapshot = null; undoStack = []; buildMode=true; updateToolbarVisibility(); draw(); });

/* Reset & Undo */
function resetToSaved(){ if(!savedSnapshot) return; restoreState(savedSnapshot); undoStack = [ cloneState() ]; }
document.getElementById('reset-btn').addEventListener('click', resetToSaved);
function doUndo(){ if(undoStack.length <= 1) return;  const prev = undoStack[undoStack.length - 1]; restoreState(prev); undoStack.pop();}
document.getElementById('undo-btn').addEventListener('click', doUndo);

/* ---------- JSON Export/Import (local download) ---------- */
document.getElementById('export-btn').addEventListener('click', ()=>{
  if(!player){ alert('Place a player first'); return; }
  const levelData = { base, boxes, player };
  const blob = new Blob([JSON.stringify(levelData, null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='level.json'; a.click(); URL.revokeObjectURL(url);
});
document.getElementById('import-btn').addEventListener('click', ()=> document.getElementById('import-file').click());
document.getElementById('import-file').addEventListener('change', (e)=>{
  const file = e.target.files[0]; if(!file) return;
  const reader = new FileReader();
  reader.onload = function(ev){
    try {
      const data = JSON.parse(ev.target.result);
      if(!data.base||!data.boxes||!data.player) throw "Invalid format";
      base = data.base.map(r=>r.slice());
      boxes = data.boxes.map(b=>({x:b.x,y:b.y}));
      player = JSON.parse(JSON.stringify(data.player));
      savedSnapshot = cloneState();
      undoStack = [ cloneState() ];
      updateToolbarVisibility();
      draw();
      alert('Level imported successfully');
    } catch(err){ alert('Failed to import JSON: '+err); }
  };
  reader.readAsText(file); e.target.value='';
});

/* ---------- LEVELS FOLDER (static in repo) ---------- */
/* Instead of server API, load from /levels/index.json (keep index.json updated in git) */

async function refreshLevelsFolderList(){
  const sel = document.getElementById('server-levels');
  sel.innerHTML = '';
  try {
    const res = await fetch('levels/index.json', { cache: "no-store" });
    if(!res.ok) throw new Error(res.status + ' ' + res.statusText);
    const list = await res.json();
    if(!Array.isArray(list)) throw new Error('index.json must be an array of filenames');
    list.forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      sel.appendChild(opt);
    });
    if(list.length === 0){
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = '(no levels found)';
      sel.appendChild(opt);
    }
  } catch(err){
    console.warn('Could not load /levels/index.json:', err);
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = '(levels/index.json not found)';
    sel.appendChild(opt);
  }
}

document.getElementById('refresh-server').addEventListener('click', refreshLevelsFolderList);

document.getElementById('load-server').addEventListener('click', async ()=>{
  const sel = document.getElementById('server-levels');
  const name = sel.value;
  if(!name) return alert('Select a level first (refresh list if needed)');
  try {
    const res = await fetch('/levels/' + encodeURIComponent(name), { cache: "no-store" });
    if(!res.ok) throw new Error(res.status + ' ' + res.statusText);
    const data = await res.json();
    if(!data.base || !data.boxes || !('player' in data)) throw new Error('Invalid level format');
    base = data.base.map(r=>r.slice());
    boxes = data.boxes.map(b=>({x:b.x,y:b.y}));
    player = JSON.parse(JSON.stringify(data.player));
    savedSnapshot = cloneState();
    undoStack = [ cloneState() ];
    //buildMode = true;
    updateToolbarVisibility();
    draw();
    //alert('Loaded level from levels/' + name);
  } catch(err){
    //alert('Failed to load levels/' + name + ': ' + err.message);
  }
});

/* Disable Save button (editing repo must be done via git). */
const saveBtn = document.getElementById('save-server');
if(saveBtn){
  saveBtn.disabled = true;
  saveBtn.title = 'Saving is disabled. Add levels to the repo levels/ folder and update levels/index.json';
}

// populate on start
refreshLevelsFolderList();


/* ---------- DRAW (improved icons) ---------- */
function drawOverlayForType(t, x, y){
  const px = x * tileSize, py = y * tileSize;
  ctx.save();
  ctx.translate(px, py);
  // set crisp line values based on tileSize
  const lw = Math.max(2, Math.floor(tileSize * 0.12));
  if(t === 'spikes'){
    // draw 5 small triangles (sharp, crisp)
    const count = 5;
    const spacing = tileSize / (count + 1);
    const triW = Math.max(4, Math.floor(tileSize * 0.12));
    const triH = Math.max(6, Math.floor(tileSize * 0.14));
    ctx.fillStyle = colors.wall;
    for(let i=1;i<=count;i++){
      const cx = spacing * i;
      const topY = tileSize*0.3;
      ctx.beginPath();
      ctx.moveTo(cx, topY);
      ctx.lineTo(cx - triW/2, topY + triH);
      ctx.lineTo(cx + triW/2, topY + triH);
      ctx.closePath();
      ctx.fill();
    }
  } else if(t === 'grile'){
    // draw a crisp '#' using strokes, in floor color on hole bg
    ctx.strokeStyle = colors.floor;
    ctx.lineWidth = Math.max(2, Math.floor(tileSize * 0.12));
    ctx.lineCap = 'round';
    const inset = tileSize * 0.18;
    const x1 = inset, x2 = tileSize - inset;
    const y1 = inset, y2 = tileSize - inset;
    // two vertical lines
    ctx.beginPath();
    ctx.moveTo(x1 + (x2-x1)/3, y1);
    ctx.lineTo(x1 + (x2-x1)/3, y2);
    ctx.moveTo(x1 + 2*(x2-x1)/3, y1);
    ctx.lineTo(x1 + 2*(x2-x1)/3, y2);
    // two horizontal lines
    ctx.moveTo(x1, y1 + (y2-y1)/3);
    ctx.lineTo(x2, y1 + (y2-y1)/3);
    ctx.moveTo(x1, y1 + 2*(y2-y1)/3);
    ctx.lineTo(x2, y1 + 2*(y2-y1)/3);
    ctx.stroke();
  } else if(t === 'pressurePlate'){
    // draw a crisp X with rounded caps in orange
    ctx.strokeStyle = '#ff6a00';
    ctx.lineWidth = Math.max(3, Math.floor(tileSize * 0.14));
    ctx.lineCap = 'round';
    const inset = tileSize * 0.22;
    ctx.beginPath();
    ctx.moveTo(inset, inset);
    ctx.lineTo(tileSize - inset, tileSize - inset);
    ctx.moveTo(tileSize - inset, inset);
    ctx.lineTo(inset, tileSize - inset);
    ctx.stroke();

    // draw small subtle ring behind the X
    ctx.beginPath();
    ctx.lineWidth = Math.max(1, Math.floor(tileSize * 0.04));
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.arc(tileSize/2, tileSize/2, tileSize*0.28, 0, Math.PI*2);
    ctx.stroke();
  }
  ctx.restore();
}

function computeExitActive(){
  const plates = [];
  for(let y=0;y<rows;y++) for(let x=0;x<cols;x++) if(base[y][x] === 'pressurePlate') plates.push({x,y});
  if(plates.length === 0) return true;
  let pressed = 0;
  for(const p of plates) if(boxAt(p.x,p.y)) pressed++;
  return pressed === plates.length;
}

function draw(){
  const exitActive = computeExitActive();

  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const t = base[y][x] || 'floor';
      let bg;
      if(t === 'exit') bg = exitActive ? colors.exitActive : colors.exitInactive;
      else bg = blockBgColor[t] !== undefined ? blockBgColor[t] : colors.floor;
      ctx.fillStyle = bg;
      ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
      ctx.strokeStyle = '#ddd';
      ctx.strokeRect(x*tileSize, y*tileSize, tileSize, tileSize);

      if(['spikes','grile','pressurePlate'].includes(t)) drawOverlayForType(t, x, y);
    }
  }

  // boxes
  for(const b of boxes){
    if(player && player.mode === 'inbox' && player.x === b.x && player.y === b.y) continue;
    ctx.fillStyle = colors.box;
    ctx.fillRect(b.x*tileSize+4, b.y*tileSize+4, tileSize-8, tileSize-8);
  }

  // free player
  if(player && player.mode === 'free'){
    ctx.fillStyle = colors.player;
    const cx = player.x*tileSize + tileSize/2;
    const cy = player.y*tileSize + tileSize/2;
    const r = tileSize * 0.32;
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
  }

  // mixed tile player-in-box
  if(player && player.mode === 'inbox'){
    const bx = player.x, by = player.y;
    ctx.fillStyle = colors.box;
    ctx.fillRect(bx*tileSize+4, by*tileSize+4, tileSize-8, tileSize-8);
    const dx = player.entryDir.dx, dy = player.entryDir.dy;
    ctx.save(); ctx.fillStyle = colors.player;
    if(dx === 1) ctx.fillRect(bx*tileSize+4, by*tileSize+4, (tileSize-8)/2, tileSize-8);
    else if(dx === -1) ctx.fillRect(bx*tileSize+4 + (tileSize-8)/2, by*tileSize+4, (tileSize-8)/2, tileSize-8);
    else if(dy === 1) ctx.fillRect(bx*tileSize+4, by*tileSize+4, tileSize-8, (tileSize-8)/2);
    else if(dy === -1) ctx.fillRect(bx*tileSize+4, by*tileSize+4 + (tileSize-8)/2, tileSize-8, (tileSize-8)/2);
    ctx.restore();
    ctx.strokeStyle = '#333'; ctx.strokeRect(bx*tileSize+4, by*tileSize+4, tileSize-8, tileSize-8);
  }
}

/* ---------- GAME LOGIC: attribute-driven (keeps previous mechanics) ---------- */
function pushSnapshot(){ undoStack.push(cloneState()); }

function attemptMove(dx,dy){
  if(buildMode || !player) return;

  if(player.mode === 'free'){
    const nx = player.x + dx, ny = player.y + dy;
    if(!inBounds(nx, ny)) return;
    const targetType = base[ny][nx] || 'floor';
    if(attr(targetType, 'isWallForPlayer')) return;
    const targetBox = boxAt(nx, ny);
    if(targetBox){
      pushSnapshot();
      player = { mode:'inbox', x:nx, y:ny, entryDir: {dx, dy} };
      draw();
      return;
    }
    pushSnapshot();
    player.x = nx; player.y = ny;
    if(attr(targetType, 'isHoleForPlayer')){
      draw();
      setTimeout(()=>{ alert('Game Over — fell into hole'); }, 10);
      return;
    }
    if(attr(targetType, 'isEnd')){
      if(computeExitActive()){ draw(); setTimeout(()=>{ alert('You Win! (free on exit)'); }, 10); return; }
    }
    draw();
    return;
  } else if(player.mode === 'inbox'){
    const fromX = player.x, fromY = player.y;
    const tx = fromX + dx, ty = fromY + dy;
    if(!inBounds(tx,ty)) return;
    const targetType = base[ty][tx] || 'floor';
    if(dx === -player.entryDir.dx && dy === -player.entryDir.dy && !attr(targetType, 'isWallForPlayer')){
    // if attempting to move opposite of entry -> flight
      pushSnapshot();
      performFlight(dx, dy);
      return;
    }
    else {
        // cannot exit/move into tile if it's wall for boxes
        if(attr(targetType, 'isWallForBox')) return;
    }
    const other = boxAt(tx,ty);
    if(other){
      const bx2 = tx + dx, by2 = ty + dy;
      if(!inBounds(bx2,by2)) return;
      const beyondType = base[by2][bx2] || 'floor';
      if(attr(beyondType, 'isWallForBox') || boxAt(bx2,by2)) return;
      pushSnapshot();
      if(attr(beyondType, 'isHoleForBox')){
        removeBoxAt(tx,ty);
        moveBox(fromX,fromY,tx,ty);
        player.x = tx; player.y = ty;
        if(attr(base[player.y][player.x], 'isHoleForBox')){
          draw(); setTimeout(()=>{ alert('Game Over — your box fell into a hole'); }, 10); return;
        }
        draw(); return;
      } else {
        moveBox(tx,ty,bx2,by2);
        moveBox(fromX,fromY,tx,ty);
        player.x = tx; player.y = ty;
        draw(); return;
      }
    } else {
      if(attr(targetType, 'isHoleForBox')){
        pushSnapshot();
        removeBoxAt(fromX,fromY);
        draw();
        setTimeout(()=>{ alert('Game Over — your box fell into a hole'); }, 10);
        return;
      }
      pushSnapshot();
      moveBox(fromX,fromY,tx,ty);
      player.x = tx; player.y = ty;
      draw();
      return;
    }
  }
}

function performFlight(dx,dy){
  let cx = player.x, cy = player.y;
  while(true){
    const nx = cx + dx, ny = cy + dy;
    if(!inBounds(nx, ny)){
      concludeFlightAt(cx, cy, dx, dy); return;
    }
    const nextType = base[ny][nx] || 'floor';
    if(attr(nextType, 'isNotFly')){
      concludeFlightAt(cx, cy, dx, dy); return;
    }
    if(attr(nextType, 'isStickOnFly')){
      const bx = boxAt(nx, ny);
      if(bx){ player = { mode:'inbox', x:nx, y:ny, entryDir:{dx,dy} }; draw(); return; }
      else { player = { mode:'free', x:nx, y:ny }; draw();
        if(attr(nextType, 'isHoleForPlayer')){ setTimeout(()=>{ alert('Game Over — fell into hole'); }, 10); return; }
        if(attr(nextType, 'isEnd') && computeExitActive()){ setTimeout(()=>{ alert('You Win! (free on exit)'); }, 10); return; }
        return;
      }
    }
    const bx = boxAt(nx, ny);
    if(bx){ player = { mode:'inbox', x:nx, y:ny, entryDir:{dx,dy} }; draw(); return; }
    cx = nx; cy = ny;
  }
}

function concludeFlightAt(cx,cy,dx,dy){
  const b = boxAt(cx,cy);
  if(b){ player = { mode:'inbox', x:cx, y:cy, entryDir:{dx,dy} }; draw(); return; }
  player = { mode:'free', x:cx, y:cy }; draw();
  const t = base[cy][cx] || 'floor';
  if(attr(t, 'isHoleForPlayer')){ setTimeout(()=>{ alert('Game Over — fell into hole'); }, 10); return; }
  if(attr(t, 'isEnd') && computeExitActive()){ setTimeout(()=>{ alert('You Win! (free on exit)'); }, 10); return; }
}

/* ---------- INIT ---------- */
updateToolbarVisibility();
draw();

</script>
</body>
</html>
