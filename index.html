<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Box-Enter Puzzle Prototype — Server Levels & Cleaner Icons</title>
<style>
body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding:12px; }
#game { border:1px solid #222; image-rendering: crisp-edges; display:block; margin-bottom:12px;}
.toolbar { margin-bottom:6px; }
.toolbar button, .toolbar select { margin-right:6px; margin-bottom:6px; }
.status { font-weight:600; margin-bottom:12px; }
small.hint { color:#666; display:block; margin-top:6px; }
.hidden { display:none !important; }
</style>
</head>
<body>
<h3>Box-Enter Puzzle Prototype — Server Levels & Cleaner Icons</h3>
<canvas id="game" width="480" height="480"></canvas>
<div id="bigMessage" style="font-size:26px;font-weight:800;text-align:center;margin-top:12px;min-height:34px;"></div>

<div class="toolbar">
    <div>
        <button id="build-mode-btn">Toggle Build Mode</button>
        <!-- Levels chooser (paste into the toolbar so you can pick levels from levels/) -->
<div style="margin-top:6px;">
  <label for="server-levels" style="font-size:12px;margin-right:6px;">Levels:</label>
  <select id="server-levels" style="min-width:220px;"></select>
  <button id="refresh-server">Refresh</button>
  <button id="load-server">Load</button>
</div>

    </div>
  <div class="build-controls">
    <div>
      <div>
        <button data-tile="wall">Wall</button>
        <button data-tile="floor">Floor</button>
        <button data-tile="hole">Hole</button>
        <button data-tile="exit">Exit</button>
      </div>
      <div>
        <button data-tile="spikes">Spikes</button>
        <button data-tile="grile">Grile</button>
        <button data-tile="fragileWall">Fragile Wall</button>
        <button data-tile="pressurePlate">Pressure Plate</button>
        <button data-tile="holeSpikes">Hole Spikes</button>
        <button data-tile="slimPathFloor">Slim Path Floor</button>
        <button data-tile="slimPathHole">Slim Path Hole</button>
      </div>
      <div>
        <button data-tile="box">Box</button>
        <button data-tile="player">Player</button>
      </div>
    </div>
    <div>
    <button id="export-btn">Export JSON</button>
    <button id="import-btn">Import JSON</button>
    <button id="clear-btn">Clear</button>
    <button id="fill-floor">Fill Floor</button>
    </div>
  </div>

  <div class="play-controls" style="margin-top:6px;">
    <button id="reset-btn">Reset (R)</button>
    <button id="undo-btn">Undo (E)</button>
    <input type="file" id="import-file" style="display:none"/>
  </div>

  <small class="hint">
    Build Mode ON: paint/place/remove. Build Mode OFF: play (WASD). Drag to paint tiles (wall/floor/hole/exit/spikes/grile/pressurePlate). Export/Import levels via JSON.
  </small>
</div>

<div class="status" id="status">Build Mode: OFF</div>

<script>
/* ---------- CONFIG ---------- */
const rows = 12;
const cols = 12;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const tileSize = Math.floor(canvas.width / cols);

/* visual colors */
const colors = {
  empty: '#ffffff',
  wall: '#777777',     // dark grey
  floor: '#fafafa',
  hole: '#000000',     // black
  exitActive: '#3cb371',
  exitInactive: '#bfecc4', // pale green
  box: '#f39c12',
  player: '#4c3ce7'
};

/* ---------- BLOCK TYPES (attributes) ---------- */
const BlockTypes = {
  floor: {},
  wall: { isWallForPlayer:true, isWallForBox:true, isNotFly:true },
  hole: { isHoleForPlayer:true, isHoleForBox:true },
  exit: { isEnd:true },
  spikes: { isWallForBox:true, isStickOnFly:true },
  grile: { isHoleForPlayer:true, isHoleForBox:false },
  pressurePlate: { requiresBox:true },
  holeSpikes: { isWallForBox:true, isStickOnFly:true, isHoleForPlayer:true },
  slimPathFloor: { isWallForBox:true },
  slimPathHole: { isWallForBox:true, isHoleForPlayer:true },
  fragileWall: { isFragile:true, isWallForPlayer:true, isWallForBox:true, isNotFly:true }
};

const blockBgColor = {
  floor: colors.floor,
  wall: colors.wall,
  hole: colors.hole,
  exit: colors.exitActive,
  spikes: colors.floor,
  grile: colors.hole,
  pressurePlate: colors.floor,
  holeSpikes: colors.hole,        // hole background with spike overlay
  slimPathFloor: colors.floor,    // floor bg
  slimPathHole: colors.hole,       // hole bg for the hole variant
  fragileWall: colors.wall

};

/* ---------- STATE ---------- */
let base = Array.from({length: rows}, ()=> Array.from({length: cols}, ()=> 'floor'));
let boxes = [];
let player = null;
let buildMode = false;
let selectedTool = 'wall';
let savedSnapshot = null;
let undoStack = [];
let mouseDown = false;
let gameState = null;
// Falling-box visual animations (independent of internal logic)
let fallingAnims = []; // { x, y, start, duration }
let animRunning = false;

function animateBoxFall(x, y, duration = 1000){
  // x,y are grid coords (integers)
  fallingAnims.push({ x, y, start: performance.now(), duration });
  startAnimLoop();
}

function startAnimLoop(){
  if(animRunning) return;
  animRunning = true;
  requestAnimationFrame(animLoop);
}

function animLoop(ts){
  // call the normal draw which paints the current game state
  draw();
  // then paint the falling animations on top
  drawFallingAnims(performance.now());
  if(fallingAnims.length > 0){
    requestAnimationFrame(animLoop);
  } else {
    animRunning = false;
  }
}

function drawFallingAnims(now){
  // draw overlay animations for boxes that just "fell into holes"
  // each anim shrinks and darkens over its duration, then is removed
  if(!fallingAnims.length) return;
  // iterate a copy because we may remove while iterating
  const next = [];
  for(const a of fallingAnims){
    const t = now - a.start;
    const p = Math.max(0, Math.min(1, t / a.duration)); // 0..1
    if(p >= 1) {
      // finished -> don't keep
      continue;
    }
    // compute size and alpha: start ~ full size, end smaller and darker
    const startSize = tileSize - 8;
    const scale = 1 - 0.75 * p;        // shrink to 25% size
    const size = Math.max(2, Math.floor(startSize * scale));
    const cx = a.x * tileSize + tileSize/2;
    const cy = a.y * tileSize + tileSize/2;
    // alpha fades a bit (we also let hole background show through darker color)
    const alpha = 1 - 0.7 * p;

    ctx.save();
    ctx.globalAlpha = alpha;
    // draw the box (centered)
    ctx.fillStyle = colors.box;
    ctx.fillRect(Math.round(cx - size/2), Math.round(cy - size/2), size, size);
    // draw a subtle dark overlay to simulate it falling 'into' the hole
    ctx.fillStyle = `rgba(0,0,0,${0.4 * p})`;
    ctx.fillRect(Math.round(cx - size/2), Math.round(cy - size/2), size, size);
    ctx.restore();

    next.push(a);
  }
  fallingAnims = next;
}


function setGameState(state, message){
  gameState = state; // state: 'win' or 'lose' or null
  const el = document.getElementById('bigMessage');
  if(!el) return;
  if(state === 'win'){
    el.textContent = message || 'You Win!';
    el.style.color = 'green';
  } else if(state === 'lose'){
    el.textContent = message || 'You Lose';
    el.style.color = 'crimson';
  } else {
    el.textContent = '';
  }
}

/* ---------- HELPERS ---------- */
function cloneState(){ return { base: base.map(r=>r.slice()), boxes: boxes.map(b=>({x:b.x,y:b.y})), player: player? JSON.parse(JSON.stringify(player)):null }; }
function restoreState(snap){ base = snap.base.map(r=>r.slice()); boxes = snap.boxes.map(b=>({x:b.x,y:b.y})); player = snap.player? JSON.parse(JSON.stringify(snap.player)) : null; updateToolbarVisibility(); draw(); }
function inBounds(x,y){ return x>=0 && x<cols && y>=0 && y<rows; }
function boxAt(x,y){ return boxes.find(b=>b.x===x && b.y===y); }
function removeBoxAt(x,y){ boxes = boxes.filter(b=>!(b.x===x && b.y===y)); }
function addBox(x,y){ if(!boxAt(x,y)) boxes.push({x,y}); }
function moveBox(fromX,fromY,toX,toY){ for(let b of boxes){ if(b.x===fromX && b.y===fromY){ b.x=toX; b.y=toY; return true; } } return false; }
function attr(type, key){ if(!type) return false; const def = BlockTypes[type]; if(!def) return false; return !!def[key]; }

/* ---------- UI: toolbar visibility & selection ---------- */
function updateToolbarVisibility(){
  const buildControls = document.querySelector('.build-controls');
  const playControls = document.querySelector('.play-controls');
  if(buildMode){
    buildControls.classList.remove('hidden');
    playControls.classList.add('hidden');
  } else {
    buildControls.classList.add('hidden');
    playControls.classList.remove('hidden');
  }
  document.getElementById('status').textContent = `Build Mode: ${buildMode ? 'ON' : 'OFF'}`;
}

document.querySelectorAll('.build-controls button[data-tile]').forEach(b=>{
  b.addEventListener('click', ()=> {
    selectedTool = b.dataset.tile;
    document.querySelectorAll('.build-controls button[data-tile]').forEach(btn=> btn.style.outline='');
    b.style.outline = '2px solid #888';
  });
});
document.querySelector('.build-controls button[data-tile="wall"]').style.outline='2px solid #888';

document.getElementById('build-mode-btn').addEventListener('click', ()=>{
  buildMode = !buildMode;
  if(!buildMode){
    savedSnapshot = cloneState();
    undoStack = [ cloneState() ]; // initialize undo with starting state
  }
  updateToolbarVisibility();
  draw();
});

/* ---------- BUILD: click/drag behavior ---------- */
function handleBuildClick(e){
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left)/tileSize);
  const y = Math.floor((e.clientY - rect.top)/tileSize);
  if(!inBounds(x,y)) return;

  if(selectedTool === 'player'){
    if(player && player.x === x && player.y === y) player = null;
    else { player = { mode: 'free', x, y }; if(!base[y][x]) base[y][x] = 'floor'; }
    draw(); return;
  }
  if(selectedTool === 'box'){
    const existing = boxAt(x,y);
    if(existing) removeBoxAt(x,y);
    else { addBox(x,y); if(!base[y][x]) base[y][x] = 'floor'; }
    draw(); return;
  }

  // paint blocks (tile types)
  base[y][x] = selectedTool;
  draw();
}
function handleBuildDrag(e){
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left)/tileSize);
  const y = Math.floor((e.clientY - rect.top)/tileSize);
  if(!inBounds(x,y)) return;
  if(['wall','floor','hole','exit','spikes','grile','pressurePlate','holeSpikes','slimPathFloor','slimPathHole','fragileWall'].includes(selectedTool)){
    base[y][x] = selectedTool;
    draw();
  }
}

canvas.addEventListener('mousedown', (e)=>{ if(!buildMode) return; mouseDown = true; handleBuildClick(e); });
canvas.addEventListener('mousemove', (e)=>{ if(!mouseDown || !buildMode) return; handleBuildDrag(e); });
canvas.addEventListener('mouseup', ()=>{ mouseDown=false; });
canvas.addEventListener('mouseleave', ()=>{ mouseDown=false; });

/* ---------- SHORTCUTS ---------- */
window.addEventListener('keydown', (e)=>{
  const key = e.key.toLowerCase();
  if(buildMode){
    if(key === 'e'){ doUndo(); e.preventDefault(); }
    if(key === 'r'){ resetToSaved(); e.preventDefault(); }
    return;
  }
  let dx=0,dy=0;
  if(key==='w') dy=-1;
  else if(key==='s') dy=1;
  else if(key==='a') dx=-1;
  else if(key==='d') dx=1;
  else if(key==='e'){ doUndo(); e.preventDefault(); return; }
  else if(key==='r'){ resetToSaved(); e.preventDefault(); return; }
  else return;
  e.preventDefault();
  attemptMove(dx,dy);
});

/* ---------- UI buttons ---------- */
document.getElementById('fill-floor').addEventListener('click', ()=>{ for(let y=0;y<rows;y++) for(let x=0;x<cols;x++) base[y][x]='floor'; draw(); });
document.getElementById('clear-btn').addEventListener('click', ()=>{
  if(!confirm('Clear map? This will remove boxes, player and tiles. Proceed?')) return;
  base = Array.from({length: rows}, ()=> Array.from({length: cols}, ()=> 'floor'));
  boxes = []; player = null; savedSnapshot = null; undoStack = []; buildMode=true; updateToolbarVisibility(); draw();
  setGameState(null);
});

/* Reset & Undo */
function resetToSaved(){
  if(!savedSnapshot) return;
  restoreState(savedSnapshot);
  undoStack = [ cloneState() ];
  setGameState(null);
}

document.getElementById('reset-btn').addEventListener('click', resetToSaved);
function doUndo(){
  if(undoStack.length <= 1) return;
  undoStack.pop();
  const prev = undoStack[undoStack.length - 1];
  restoreState(prev);

  // after restoring, check whether restored state is terminal; if not, clear any message
  const snap = cloneState();
  // check for lose: any box on hole OR player free on hole
  let terminalLose = false;
  for(let y=0;y<rows;y++) for(let x=0;x<cols;x++){
    const t = snap.base[y][x] || 'floor';
    if(attr(t, 'isHoleForBox') && snap.boxes.some(b=>b.x===x && b.y===y)){ terminalLose = true; }
  }
  if(snap.player){
    if(snap.player.mode === 'free' && attr(snap.base[snap.player.y][snap.player.x],'isHoleForPlayer')) terminalLose = true;
  }
  if(terminalLose){ setGameState('lose','Game Over — your box fell into a hole'); return; }

  // check for win (player free on active exit)
  if(snap.player && snap.player.mode === 'free'){
    const t = snap.base[snap.player.y][snap.player.x] || 'floor';
    if(attr(t,'isEnd') && computeExitActive()){ setGameState('win','You Win!'); return; }
  }

  // otherwise clear message
  setGameState(null);
}

document.getElementById('undo-btn').addEventListener('click', doUndo);

/* ---------- JSON Export/Import (local download) ---------- */
document.getElementById('export-btn').addEventListener('click', ()=>{
  if(!player){ alert('Place a player first'); return; }
  const levelData = { base, boxes, player };
  const blob = new Blob([JSON.stringify(levelData, null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='level.json'; a.click(); URL.revokeObjectURL(url);
});
document.getElementById('import-btn').addEventListener('click', ()=> document.getElementById('import-file').click());
document.getElementById('import-file').addEventListener('change', (e)=>{
  const file = e.target.files[0]; if(!file) return;
  const reader = new FileReader();
  reader.onload = function(ev){
    try {
      const data = JSON.parse(ev.target.result);
      if(!data.base||!data.boxes||!data.player) throw "Invalid format";
      base = data.base.map(r=>r.slice());
      boxes = data.boxes.map(b=>({x:b.x,y:b.y}));
      player = JSON.parse(JSON.stringify(data.player));
      savedSnapshot = cloneState();
      undoStack = [ cloneState() ];
      updateToolbarVisibility();
      draw();
      alert('Level imported successfully');
    } catch(err){ alert('Failed to import JSON: '+err); }
  };
  reader.readAsText(file); e.target.value='';
});

/* ---------- LEVELS FOLDER (static in repo) ---------- */
/* Instead of server API, load from levels/index.json (keep index.json updated in git) */

async function refreshLevelsFolderList(){
  const sel = document.getElementById('server-levels');
  sel.innerHTML = '';
  try {
    const res = await fetch('levels/index.json', { cache: "no-store" });
    if(!res.ok) throw new Error(res.status + ' ' + res.statusText);
    const list = await res.json();
    if(!Array.isArray(list)) throw new Error('index.json must be an array of filenames');
    list.forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      sel.appendChild(opt);
    });
    if(list.length === 0){
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = '(no levels found)';
      sel.appendChild(opt);
    }
  } catch(err){
    console.warn('Could not load levels/index.json:', err);
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = '(levels/index.json not found)';
    sel.appendChild(opt);
  }
}

document.getElementById('refresh-server').addEventListener('click', refreshLevelsFolderList);

document.getElementById('load-server').addEventListener('click', async ()=>{
  const sel = document.getElementById('server-levels');
  const name = sel.value;
  if(!name) return alert('Select a level first (refresh list if needed)');
  if(!confirm('Load "' + name + '"? Unsaved changes will be lost.')) return;
  try {
    const res = await fetch('levels/' + encodeURIComponent(name), { cache: "no-store" });
    if(!res.ok) throw new Error(res.status + ' ' + res.statusText);
    const data = await res.json();
    if(!data.base || !data.boxes || !('player' in data)) throw new Error('Invalid level format');
    base = data.base.map(r=>r.slice());
    boxes = data.boxes.map(b=>({x:b.x,y:b.y}));
    player = JSON.parse(JSON.stringify(data.player));
    savedSnapshot = cloneState();
    undoStack = [ cloneState() ];
    //buildMode = true;
    updateToolbarVisibility();
    draw();
    //alert('Loaded level from levels/' + name);
  } catch(err){
    //alert('Failed to load levels/' + name + ': ' + err.message);
  }
});

/* Disable Save button (editing repo must be done via git). */
const saveBtn = document.getElementById('save-server');
if(saveBtn){
  saveBtn.disabled = true;
  saveBtn.title = 'Saving is disabled. Add levels to the repo levels/ folder and update levels/index.json';
}

// populate on start
refreshLevelsFolderList();


/* ---------- DRAW (improved icons) ---------- */
function drawOverlayForType(t, x, y){
  const px = x * tileSize, py = y * tileSize;
  ctx.save();
  ctx.translate(px, py);
  // set crisp line values based on tileSize
  const lw = Math.max(2, Math.floor(tileSize * 0.12));
  if(t === 'spikes' || t === 'holeSpikes'){
    // draw 5 small triangles (sharp, crisp)
    const count = 5;
    const spacing = tileSize / (count + 1);
    const triW = Math.max(4, Math.floor(tileSize * 0.12));
    const triH = Math.max(6, Math.floor(tileSize * 0.14));
    ctx.fillStyle = colors.wall;
    for(let i=1;i<=count;i++){
      const cx = spacing * i;
      const topY = tileSize*0.3;
      ctx.beginPath();
      ctx.moveTo(cx, topY);
      ctx.lineTo(cx - triW/2, topY + triH);
      ctx.lineTo(cx + triW/2, topY + triH);
      ctx.closePath();
      ctx.fill();
    }
  } else if(t === 'grile'){
    // draw a crisp '#' using strokes, in floor color on hole bg
    ctx.strokeStyle = colors.floor;
    ctx.lineWidth = Math.max(2, Math.floor(tileSize * 0.12));
    ctx.lineCap = 'round';
    const inset = tileSize * 0.18;
    const x1 = inset, x2 = tileSize - inset;
    const y1 = inset, y2 = tileSize - inset;
    // two vertical lines
    ctx.beginPath();
    ctx.moveTo(x1 + (x2-x1)/3, y1);
    ctx.lineTo(x1 + (x2-x1)/3, y2);
    ctx.moveTo(x1 + 2*(x2-x1)/3, y1);
    ctx.lineTo(x1 + 2*(x2-x1)/3, y2);
    // two horizontal lines
    ctx.moveTo(x1, y1 + (y2-y1)/3);
    ctx.lineTo(x2, y1 + (y2-y1)/3);
    ctx.moveTo(x1, y1 + 2*(y2-y1)/3);
    ctx.lineTo(x2, y1 + 2*(y2-y1)/3);
    ctx.stroke();
  } else if(t === 'pressurePlate'){
    // draw a crisp X with rounded caps in orange
    ctx.strokeStyle = '#ff6a00';
    ctx.lineWidth = Math.max(3, Math.floor(tileSize * 0.14));
    ctx.lineCap = 'round';
    const inset = tileSize * 0.22;
    ctx.beginPath();
    ctx.moveTo(inset, inset);
    ctx.lineTo(tileSize - inset, tileSize - inset);
    ctx.moveTo(tileSize - inset, inset);
    ctx.lineTo(inset, tileSize - inset);
    ctx.stroke();

    // draw small subtle ring behind the X
    ctx.beginPath();
    ctx.lineWidth = Math.max(1, Math.floor(tileSize * 0.04));
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.arc(tileSize/2, tileSize/2, tileSize*0.28, 0, Math.PI*2);
    ctx.stroke();
  } else if(t === 'slimPathFloor' || t === 'slimPathHole'){
    // draw dots on the edges of the square (4 edges x 3 dots each) in wall color
    ctx.fillStyle = colors.wall;
    const dotR = Math.max(1, Math.floor(tileSize * 0.06));
    const margin = Math.max(2, Math.floor(tileSize * 0.02));
    // top row
    const colsCount = 2;
    for(let i=0;i<colsCount;i++){
      const xPos = margin + (tileSize - margin*2) * (i/(colsCount-1));
      ctx.beginPath(); ctx.arc(xPos, margin, dotR, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(xPos, tileSize - margin, dotR, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(margin, margin + (tileSize - margin*2) * (i/(colsCount-1)), dotR, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(tileSize - margin, margin + (tileSize - margin*2) * (i/(colsCount-1)), dotR, 0, Math.PI*2); ctx.fill();
    }
  } else if(t === 'fragileWall'){
    // wall background already drawn; overlay a jagged crack line to indicate fragility
    ctx.strokeStyle = '#222'; // dark line for crack
    ctx.lineWidth = Math.max(2, Math.floor(tileSize * 0.08));
    ctx.lineCap = 'round';
    ctx.lineJoin = 'miter';

    const inset = tileSize * 0.18;
    // create a jagged polyline across the tile
    const pts = [
      {x: inset, y: tileSize*0.35},
      {x: inset + tileSize*0.08, y: tileSize*0.45},
      {x: inset + tileSize*0.18, y: tileSize*0.3},
      {x: inset + tileSize*0.32, y: tileSize*0.5},
      {x: inset + tileSize*0.5, y: tileSize*0.28},
      {x: inset + tileSize*0.68, y: tileSize*0.6},
      {x: tileSize - inset - tileSize*0.02, y: tileSize*0.35}
    ];

    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++){
      ctx.lineTo(pts[i].x, pts[i].y);
    }
    ctx.stroke();

    // subtle highlight on one side of the crack
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = Math.max(1, Math.floor(tileSize * 0.03));
    ctx.beginPath();
    for(let i=0;i<pts.length;i++){
      const p = pts[i];
      // offset slightly along normal (simple y-offset for subtlety)
      ctx.lineTo(p.x, p.y - Math.max(1, Math.floor(tileSize*0.02)));
    }
    ctx.stroke();
  }
  ctx.restore();
}

function computeExitActive(){
  const plates = [];
  for(let y=0;y<rows;y++) for(let x=0;x<cols;x++) if(base[y][x] === 'pressurePlate') plates.push({x,y});
  if(plates.length === 0) return true;
  let pressed = 0;
  for(const p of plates) if(boxAt(p.x,p.y)) pressed++;
  return pressed === plates.length;
}

function draw(){
  const exitActive = computeExitActive();

  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const t = base[y][x] || 'floor';
      let bg;
      if(t === 'exit') bg = exitActive ? colors.exitActive : colors.exitInactive;
      else bg = blockBgColor[t] !== undefined ? blockBgColor[t] : colors.floor;
      ctx.fillStyle = bg;
      ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
      ctx.strokeStyle = '#ddd';
      ctx.strokeRect(x*tileSize, y*tileSize, tileSize, tileSize);
      if(['spikes','grile','pressurePlate','holeSpikes','slimPathFloor','slimPathHole','fragileWall'].includes(t)) drawOverlayForType(t, x, y);
    }
  }

  // boxes
  for(const b of boxes){
    if(player && player.mode === 'inbox' && player.x === b.x && player.y === b.y) continue;
    ctx.fillStyle = colors.box;
    ctx.fillRect(b.x*tileSize+4, b.y*tileSize+4, tileSize-8, tileSize-8);
  }

  // free player
  if(player && player.mode === 'free'){
    ctx.fillStyle = colors.player;
    const cx = player.x*tileSize + tileSize/2;
    const cy = player.y*tileSize + tileSize/2;
    const r = tileSize * 0.32;
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
  }

  // mixed tile player-in-box
  if(player && player.mode === 'inbox'){
    const bx = player.x, by = player.y;
    ctx.fillStyle = colors.box;
    ctx.fillRect(bx*tileSize+4, by*tileSize+4, tileSize-8, tileSize-8);
    const dx = player.entryDir.dx, dy = player.entryDir.dy;
    ctx.save(); ctx.fillStyle = colors.player;
    if(dx === 1) ctx.fillRect(bx*tileSize+4, by*tileSize+4, (tileSize-8)/2, tileSize-8);
    else if(dx === -1) ctx.fillRect(bx*tileSize+4 + (tileSize-8)/2, by*tileSize+4, (tileSize-8)/2, tileSize-8);
    else if(dy === 1) ctx.fillRect(bx*tileSize+4, by*tileSize+4, tileSize-8, (tileSize-8)/2);
    else if(dy === -1) ctx.fillRect(bx*tileSize+4, by*tileSize+4 + (tileSize-8)/2, tileSize-8, (tileSize-8)/2);
    ctx.restore();
    ctx.strokeStyle = '#333'; ctx.strokeRect(bx*tileSize+4, by*tileSize+4, tileSize-8, tileSize-8);
  }
}

/* ---------- GAME LOGIC: attribute-driven (keeps previous mechanics) ---------- */
function pushSnapshot(){ undoStack.push(cloneState()); }

function attemptMove(dx,dy){
  if(buildMode || !player) return;
  if(gameState) return;
  if(player.mode === 'free'){
    const nx = player.x + dx, ny = player.y + dy;
    if(!inBounds(nx, ny)) return;
    const targetType = base[ny][nx] || 'floor';
    if(attr(targetType, 'isWallForPlayer')) return;
    const targetBox = boxAt(nx, ny);
    if(targetBox){
      pushSnapshot();
      player = { mode:'inbox', x:nx, y:ny, entryDir: {dx, dy} };
      draw();
      return;
    }
    pushSnapshot();
    player.x = nx; player.y = ny;
    if(attr(targetType, 'isHoleForPlayer')){
      draw();
      setGameState('lose', 'Game Over — fell into hole');
      return;
    }
    if(attr(targetType, 'isEnd')){
      if(computeExitActive()){ draw(); setGameState('win', 'You Win!'); return; }
    }
    draw();
    return;
  } else if(player.mode === 'inbox'){
    const fromX = player.x, fromY = player.y;
    const tx = fromX + dx, ty = fromY + dy;
    if(!inBounds(tx,ty)) return;
    const targetType = base[ty][tx] || 'floor';
    if(dx === -player.entryDir.dx && dy === -player.entryDir.dy && !attr(targetType, 'isWallForPlayer')){
    // if attempting to move opposite of entry -> flight
      pushSnapshot();
      performFlight(dx, dy);
      return;
    }
    else {
        // cannot exit/move into tile if it's wall for boxes
        if(attr(targetType, 'isWallForBox')) return;
    }
    const other = boxAt(tx,ty);
    if(other){
      const bx2 = tx + dx, by2 = ty + dy;
      if(!inBounds(bx2,by2)) return;
      const beyondType = base[by2][bx2] || 'floor';
      if(attr(beyondType, 'isWallForBox') || boxAt(bx2,by2)) return;
      pushSnapshot();
      if(attr(beyondType, 'isHoleForBox')){
        // remove the pushed box at its destination (bx2,by2) and animate it falling there
        // note: the 'other' box was originally at tx,ty and would be moved to bx2,by2 then vanish.
        // remove the 'other' from its original spot first
        removeBoxAt(tx, ty);
        // place player's box into tx,ty (visual move)
        moveBox(fromX, fromY, tx, ty);

        // animate the pushed box falling into the target hole (bx2,by2)
        animateBoxFall(bx2, by2, 1000);

        // if player's box ended up on a hole-for-box (rare), resolve it visually too:
        if(attr(base[ty][tx], 'isHoleForBox')){
          player = { mode: 'free', x: tx, y: ty };
          draw();
          setGameState('lose', 'Game Over — your box fell into a hole');
          return;
        }

        player.x = tx; player.y = ty;
        draw();
        return;
      } else {
        moveBox(tx,ty,bx2,by2);
        moveBox(fromX,fromY,tx,ty);
        player.x = tx; player.y = ty;
        draw(); return;
      }
    } else {
      // moving player's box into an empty tile (no other box)
      if(attr(targetType, 'isHoleForBox')){
        pushSnapshot();
        removeBoxAt(fromX, fromY);
        // start the visual falling animation at the hole tile
        animateBoxFall(tx, ty, 1000);
        // player becomes free at the hole tile (and then loses)
        player = { mode: 'free', x: tx, y: ty };
        // draw will be called by anim loop (we call draw() once to update immediately)
        draw();
        setGameState('lose', 'Game Over — your box fell into a hole');
        return;
      }
      // normal move: move player's box into the tile
      pushSnapshot();
      moveBox(fromX, fromY, tx, ty);
      player.x = tx; player.y = ty;
      draw();
      return;
    }
  }
}

function performFlight(dx,dy){
  let cx = player.x, cy = player.y;
  while(true){
    const nx = cx + dx, ny = cy + dy;
    if(!inBounds(nx, ny)){
      concludeFlightAt(cx, cy, dx, dy); return;
    }
    const nextType = base[ny][nx] || 'floor';
        // fragile tiles: if player flies into a fragile tile, it breaks (becomes floor)
    if(attr(nextType, 'isFragile')){
      base[ny][nx] = 'floor';
      //player = { mode: 'free', x: nx, y: ny };
      draw();
      //return;
    }
    if(attr(nextType, 'isNotFly')){
      concludeFlightAt(cx, cy, dx, dy); return;
    }
    if(attr(nextType, 'isStickOnFly')){
      const bx = boxAt(nx, ny);
      if(bx){ player = { mode:'inbox', x:nx, y:ny, entryDir:{dx,dy} }; draw(); return; }
      else { player = { mode:'free', x:nx, y:ny }; draw();
        if(attr(nextType, 'isHoleForPlayer')){ setGameState('lose', 'Game Over — fell into hole'); return; }
        if(attr(nextType, 'isEnd') && computeExitActive()){ setGameState('win','You Win!'); return; }
        return;
      }
    }
    const bx = boxAt(nx, ny);
    if(bx){ player = { mode:'inbox', x:nx, y:ny, entryDir:{dx,dy} }; draw(); return; }
    cx = nx; cy = ny;
  }
}

function concludeFlightAt(cx,cy,dx,dy){
  const b = boxAt(cx,cy);
  if(b){ player = { mode:'inbox', x:cx, y:cy, entryDir:{dx,dy} }; draw(); return; }
  player = { mode:'free', x:cx, y:cy }; draw();
  const t = base[cy][cx] || 'floor';
  if(attr(t, 'isHoleForPlayer')){ setGameState('lose', 'Game Over — fell into hole'); return; }
  if(attr(t, 'isEnd') && computeExitActive()){ setGameState('win','You Win!'); return; }
}

/* ---------- INIT ---------- */
updateToolbarVisibility();
draw();

</script>
</body>
</html>
