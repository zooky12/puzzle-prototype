<!doctype html>
<html lang="ca">
<head>
  <meta charset="utf-8"/>
  <title>Box-Enter Puzzle — Modular</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding:12px; }
    #game { border:1px solid #222; image-rendering: crisp-edges; display:block; margin-bottom:12px; width:480px; height:480px; }
    .toolbar { margin-bottom:6px; }
    .toolbar button, .toolbar select, .toolbar input { margin-right:6px; margin-bottom:6px; }
    .status { font-weight:600; margin-bottom:12px; }
    small.hint { color:#666; display:block; margin-top:6px; }
    .hidden { display:none !important; }
    #solverPanel { border:1px solid #ccc; padding:8px; margin-top:8px; background:#fafafa; max-width: 820px; }
    .solutionItem { font-family: monospace; margin:4px 0; display:flex; gap:8px; align-items:center; }
    .solutionItem button { margin-left:auto; }
    #bigMessage { font-size:26px;font-weight:800;text-align:center;margin-top:12px;min-height:34px; }
    .progress { font-size:13px; color:#333; margin-top:6px; }
  </style>
</head>
<body>
  <h3>Box-Enter Puzzle — Modular</h3>

  <canvas id="game" width="480" height="480"></canvas>
  <div id="bigMessage"></div>

  <div class="toolbar">
    <div>
      <button id="build-mode-btn">Toggle Build Mode</button>
      <div style="margin-top:6px;">
        <label for="server-levels" style="font-size:12px;margin-right:6px;">Levels:</label>
        <select id="server-levels" style="min-width:220px;"></select>
        <button id="refresh-server">Refresh</button>
        <button id="load-server">Load</button>
      </div>
    </div>

    <div class="build-controls hidden">
      <div>
        <div>
          <button data-tile="floor">Floor</button>
          <button data-tile="wall">Wall</button>
          <button data-tile="hole">Hole</button>
          <button data-tile="exit">Exit</button>
          <button data-tile="pressurePlate">Pressure Plate</button>
          <button data-tile="grile">Grile</button>
          <button data-tile="spikes">Spikes</button>
          <button data-tile="holeSpikes">Hole Spikes</button>
          <button data-tile="slimPathFloor">Slim Path Floor</button>
          <button data-tile="slimPathHole">Slim Path Hole</button>
        </div>
        <div style="margin-top:6px;">
          <button data-entity="box">Box</button>
          <button data-entity="heavyBox">Heavy Box</button>
          <button data-entity="fragileWall">Fragile Wall</button>
          <button data-entity="player">Player</button>
        </div>
      </div>
      <div style="margin-top:6px;">
        <button id="export-btn">Export JSON</button>
        <button id="import-btn">Import JSON</button>
        <button id="clear-btn">Clear</button>
        <button id="fill-floor">Fill Floor</button>
        <input type="file" id="import-file" style="display:none"/>
      </div>
    </div>

    <div class="play-controls" style="margin-top:6px;">
      <button id="reset-btn">Reset (R)</button>
      <button id="undo-btn">Undo (E)</button>
    </div>

    <small class="hint">
      Build Mode ON: pinta col·locant tiles i entitats (drag per pintar). OFF: juga amb WASD. Export/Import JSON.
    </small>
  </div>

  <div class="status" id="status">Build Mode: OFF</div>

  <div style="margin-top:8px;">
    <button id="toggleSolver">Toggle Solver Panel</button>
  </div>
  <div id="solverPanel" class="hidden">
    <div>
      <label>Max depth: <input id="solverMaxDepth" type="number" value="100" min="1" style="width:80px"/></label>
      <label>Max nodes: <input id="solverMaxNodes" type="number" value="200000" min="100" style="width:120px"/></label>
      <label>Max solutions: <input id="solverMaxSolutions" type="number" value="50" min="1" style="width:80px"/></label>
      <button id="runSolver">Run Solver</button>
      <button id="stopSolver" disabled>Stop</button>
    </div>
    <div class="progress" id="solverProgress">Idle</div>
    <div id="solutionsList"></div>
  </div>

  <script type="module">
    import { createEmptyState, cloneState } from './core/state.js';
    import { draw, initCanvas, animate } from './ui/canvas.js';
    import { setupBuildUI } from './ui/build.js';
    import { setupHUD } from './ui/hud.js';
    import { loadLevelList, loadLevel, exportLevel, importLevel } from './ui/io.js';
    import { stepMove } from './core/engine.js';
    import { isWinningState, isLosingState } from './core/goals.js';
    import { runSolver } from './solver/solver.js';

    // Globals (mínims per la UI)
    let state = createEmptyState(12, 12);
    let buildMode = false;
    let savedSnapshot = cloneState(state);
    let undoStack = [cloneState(state)];
    let gameState = null;

    const canvasEl = document.getElementById('game');
    initCanvas(canvasEl);

    function setGameState(type, message) {
      gameState = type;
      const el = document.getElementById('bigMessage');
      if (type === 'win') { el.textContent = message || 'You Win!'; el.style.color = 'green'; }
      else if (type === 'lose') { el.textContent = message || 'You Lose'; el.style.color = 'crimson'; }
      else { el.textContent = ''; }
    }

    function refresh() { draw(state); }
    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

    // HUD + Keybinds
    setupHUD({
      onToggleBuildMode() {
        buildMode = !buildMode;
        const buildControls = document.querySelector('.build-controls');
        const playControls = document.querySelector('.play-controls');
        document.getElementById('status').textContent = `Build Mode: ${buildMode ? 'ON' : 'OFF'}`;
        buildControls.classList.toggle('hidden', !buildMode);
        playControls.classList.toggle('hidden', buildMode);
        buildControls.querySelectorAll('button, input, select').forEach(el => { el.disabled = !buildMode; })

        // Desactivar botons per evitar clics accidentals en play mode
        buildControls.querySelectorAll('button, input, select').forEach(el => {
          el.disabled = !buildMode;
        });

        if (!buildMode) {
          savedSnapshot = cloneState(state);
          undoStack = [cloneState(state)];
        }
        refresh();
      },
      onUndo() {
        if (undoStack.length <= 1) return;
        undoStack.pop();
        state = cloneState(undoStack[undoStack.length - 1]);
        setGameState(null);
        refresh();
      },
      onReset() {
        state = cloneState(savedSnapshot);
        undoStack = [cloneState(state)];
        setGameState(null);
        refresh();
      },
      onToggleSolver() {
        document.getElementById('solverPanel').classList.toggle('hidden');
      },
      onRefreshLevels: async () => {
        const list = await loadLevelList();
        const sel = document.getElementById('server-levels');
        sel.innerHTML = '';
        if (!list || list.length === 0) {
          const opt = document.createElement('option');
          opt.value = ''; opt.textContent = '(no levels found or index.json missing)';
          sel.appendChild(opt);
        } else {
          list.forEach(name => {
            const opt = document.createElement('option');
            opt.value = name; opt.textContent = name;
            sel.appendChild(opt);
          });
        }
      },
      onLoadLevel: async () => {
        const sel = document.getElementById('server-levels');
        const name = sel.value;
        if (!name) return alert('Select a level first');
        try {
          const data = await loadLevel(name);
          state = data;
          savedSnapshot = cloneState(state);
          undoStack = [cloneState(state)];
          setGameState(null);
          refresh();
        } catch (e) {
          alert('Failed to load: ' + e.message);
        }
      },
      onExport: () => exportLevel(state),
      onImport: async (file) => {
        try {
          state = await importLevel(file);
          savedSnapshot = cloneState(state);
          undoStack = [cloneState(state)];
          setGameState(null);
          refresh();
        } catch (e) {
          alert('Failed to import: ' + e.message);
        }
      },
      onRunSolver: async ({ maxDepth, maxNodes, maxSolutions, onProgress, onSolutions }) => {
        const result = await runSolver(state, { maxDepth, maxNodes, maxSolutions, onProgress });
        onSolutions(result.solutions || []);
      },
      onStopSolver: () => { /* gestionat dins solver (flag) */ },
      onPlaySolution: async (moves) => {
        if (!savedSnapshot) return alert('No saved snapshot. Entra a Build i surt per generar-la.');
        // Reset a l’estat guardat
        state = cloneState(savedSnapshot);
        undoStack = [cloneState(state)];
        setGameState(null);
        refresh();
        await sleep(300);

        for (const ch of moves) {
          if (gameState) break;
          let dx=0, dy=0;
          if (ch==='w') dy=-1;
          else if (ch==='s') dy=1;
          else if (ch==='a') dx=-1;
          else if (ch==='d') dx=1;
          else continue;

          const { newState, effects, changed } = stepMove(state, { dx, dy });
          if (!changed) continue;

          state = newState;
          animate(effects);
          refresh();

          if (isLosingState(state)) { setGameState('lose', 'Game Over — fell into hole or box fell'); break; }
          if (isWinningState(state)) { setGameState('win', 'You Win!'); break; }

          await sleep(160); // velocitat de playback
        }
      },
      onExportSolution: (moves) => {
        const data = { moves, length: moves.length };
        const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'solution.json';
        a.click();
        URL.revokeObjectURL(url);
      }
    });

    // Build mode (pintar)
    setupBuildUI({
      canvasEl,
      getState: () => state,
      setState: (s) => { state = s; refresh(); },
      onModified: () => {},
      onSnapshot: () => { undoStack.push(cloneState(state)); },
      requestRedraw: refresh,
      isBuildMode: () => buildMode  
    });

    

    // Controls de joc
    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      if (buildMode) {
        if (key === 'e') { e.preventDefault(); document.getElementById('undo-btn').click(); }
        if (key === 'r') { e.preventDefault(); document.getElementById('reset-btn').click(); }
        return;
      }
      let dx=0, dy=0;
      if (key==='w') dy=-1;
      else if (key==='s') dy=1;
      else if (key==='a') dx=-1;
      else if (key==='d') dx=1;
      else if (key==='e') { e.preventDefault(); document.getElementById('undo-btn').click(); return; }
      else if (key==='r') { e.preventDefault(); document.getElementById('reset-btn').click(); return; }
      else return;

      e.preventDefault();
      if (gameState) return;

      const { newState, effects, changed } = stepMove(state, { dx, dy });
      if (!changed) return;

      undoStack.push(cloneState(state));
      state = newState;
      animate(effects);
      refresh();

      if (isLosingState(state)) setGameState('lose', 'Game Over — fell into hole or box fell');
      else if (isWinningState(state)) setGameState('win', 'You Win!');
      else setGameState(null);
    });

    // Primera render
    refresh();
  </script>
</body>
</html>
